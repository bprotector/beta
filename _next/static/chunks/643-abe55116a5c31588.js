(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[643],{1673:e=>{"use strict";e.exports=JSON.parse('{"version":"0.1.0","name":"bprotector","instructions":[{"name":"initialize","accounts":[{"name":"owner","isMut":true,"isSigner":true},{"name":"programState","isMut":true,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[]},{"name":"closeAccounts","accounts":[{"name":"programState","isMut":true,"isSigner":false},{"name":"owner","isMut":true,"isSigner":true},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[]},{"name":"updateFee","accounts":[{"name":"owner","isMut":true,"isSigner":true},{"name":"programState","isMut":true,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"newFee","type":"u64"}]},{"name":"setTrialTries","accounts":[{"name":"owner","isMut":true,"isSigner":true},{"name":"programState","isMut":true,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"newMaxTrials","type":"u8"}]},{"name":"storeKeys","accounts":[{"name":"user","isMut":true,"isSigner":true},{"name":"userKeyPda","isMut":true,"isSigner":false},{"name":"userTrials","isMut":true,"isSigner":false},{"name":"programState","isMut":false,"isSigner":false},{"name":"owner","isMut":true,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"fileName","type":"string"},{"name":"key1","type":"string"},{"name":"key2","type":"string"}]},{"name":"retrieveKeys","accounts":[{"name":"user","isMut":true,"isSigner":true},{"name":"userKeyPda","isMut":false,"isSigner":false},{"name":"userTrials","isMut":true,"isSigner":false},{"name":"programState","isMut":false,"isSigner":false},{"name":"owner","isMut":true,"isSigner":false},{"name":"systemProgram","isMut":false,"isSigner":false}],"args":[{"name":"fileName","type":"string"}]}],"accounts":[{"name":"ProgramState","type":{"kind":"struct","fields":[{"name":"owner","type":"publicKey"},{"name":"feeAmount","type":"u64"},{"name":"maxTrials","type":"u8"},{"name":"bump","type":"u8"}]}},{"name":"UserTrials","type":{"kind":"struct","fields":[{"name":"user","type":"publicKey"},{"name":"trialCount","type":"u8"},{"name":"bump","type":"u8"}]}},{"name":"UserKey","type":{"kind":"struct","fields":[{"name":"userPubkey","type":"publicKey"},{"name":"key1","type":"string"},{"name":"key2","type":"string"},{"name":"fileName","type":"string"},{"name":"timestamp","type":"i64"}]}}],"events":[{"name":"InitializeEvent","fields":[{"name":"programId","type":"publicKey","index":false},{"name":"programStatePda","type":"publicKey","index":false}]},{"name":"FeeUpdatedEvent","fields":[{"name":"newFee","type":"u64","index":false},{"name":"updatedBy","type":"publicKey","index":false}]},{"name":"MaxTrialsUpdatedEvent","fields":[{"name":"newMaxTrials","type":"u8","index":false},{"name":"updatedBy","type":"publicKey","index":false}]}],"errors":[{"code":6000,"name":"Unauthorized","msg":"Unauthorized access or invalid signer."},{"code":6001,"name":"InvalidFileName","msg":"Invalid file name provided."},{"code":6002,"name":"InvalidKeyLength","msg":"Invalid key length provided."},{"code":6003,"name":"InvalidFeeAmount","msg":"Fee amount cannot be zero."},{"code":6004,"name":"FeeTooLarge","msg":"Fee amount is too large."},{"code":6005,"name":"InvalidMaxTrials","msg":"Maximum trial count cannot be zero."},{"code":6006,"name":"MaxTrialsTooLarge","msg":"Maximum trial count is too large."}]}')},4618:(e,r,a)=>{"use strict";a.d(r,{A:()=>i});var t=a(5155),n=a(6874),o=a.n(n),s=a(1934);function i(e){let{activeMode:r,isContractOwner:a=!1}=e;return(0,t.jsx)("nav",{className:"nav-container mb-12",children:(0,t.jsxs)("div",{className:"glass-card p-4 flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4",children:[(0,t.jsx)(o(),{href:"/protect",className:"flex-1",children:(0,t.jsx)(s.P.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"modern-button w-full ".concat("protect"===r?"ring-2 ring-orange-400":""),children:"Protect Mode"})}),(0,t.jsx)(o(),{href:"/deprotect",className:"flex-1",children:(0,t.jsx)(s.P.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"modern-button w-full ".concat("deprotect"===r?"ring-2 ring-orange-400":""),children:"Deprotect Mode"})}),a&&(0,t.jsx)(o(),{href:"/admin",className:"flex-1",children:(0,t.jsx)(s.P.button,{whileHover:{scale:1.05},whileTap:{scale:.95},className:"modern-button w-full ".concat("admin"===r?"ring-2 ring-orange-400":""),children:"Admin"})})]})})}},7790:()=>{},9229:(e,r,a)=>{"use strict";a.d(r,{BI:()=>m,G5:()=>u,GT:()=>p,H3:()=>d,NP:()=>y,bt:()=>w,eE:()=>P,gA:()=>h,gH:()=>f,uz:()=>b,yL:()=>g,zJ:()=>S});var t=a(558),n=a(3570),o=a(5799),s=a(1673),i=a(4134).Buffer;let c=new n.PublicKey("DTh9fWEHJiktBGdZEHsMsohdmFPaCyFCL1eoTt443zWe"),l=e=>new Promise(r=>setTimeout(r,e));async function m(e,r,a){try{let l=new t.NQ(r,e,{commitment:"confirmed"}),m=new t.BP(s,c,l),[u]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],c),d=new n.Transaction,f=await m.methods.initialize().accounts({owner:e.publicKey,programState:u,systemProgram:t.SX.SystemProgram.programId}).instruction();d.add(f);let{blockhash:g,lastValidBlockHeight:y}=await r.getLatestBlockhash("confirmed");d.recentBlockhash=g,d.feePayer=e.publicKey;let p=await a(d,r);return await r.confirmTransaction({signature:p,blockhash:g,lastValidBlockHeight:y},"confirmed"),o.oR.success("Program initialized successfully!"),p}catch(e){throw o.oR.error("Failed to initialize program: ".concat(e.message)),e}}async function u(e,r,a,s,c,m,u){let d=0;for(;d<3;)try{if(!s||s.length>100)throw Error("Invalid file name");if(!c||!m||c.length>256||m.length>256)throw Error("Invalid key length");o.oR.info("Preparing to store keys...");let[l]=t.SX.PublicKey.findProgramAddressSync([i.from("user_key"),a.toBuffer(),i.from(s)],e.programId),[d]=t.SX.PublicKey.findProgramAddressSync([i.from("user_trials"),a.toBuffer()],e.programId),[f]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),g=(await e.account.programState.fetch(f)).owner,y=await r.getBalance(a),p=await r.getMinimumBalanceForRentExemption(0);if(y<p)throw Error("Insufficient SOL for transaction fees");let w=new n.Transaction,h=await e.methods.storeKeys(s,c,m).accounts({user:a,userKeyPda:l,userTrials:d,programState:f,owner:g,systemProgram:t.SX.SystemProgram.programId}).instruction();w.add(h);let{blockhash:S,lastValidBlockHeight:P}=await r.getLatestBlockhash("confirmed");w.recentBlockhash=S,w.feePayer=a,o.oR.info("Requesting wallet approval...");let b=await u(w,r);return await r.confirmTransaction({signature:b,blockhash:S,lastValidBlockHeight:P},"confirmed"),o.oR.success("Keys stored successfully!"),b}catch(r){let e=r.message||"Failed to store keys";if(r.message.includes("blockhash")&&++d<3){await l(2e3);continue}throw o.oR.error(e),Error(e)}throw Error("Failed to store keys after ".concat(3," retries"))}async function d(e,r,a,n,s){if(n.length>100)throw o.oR.error("File name must be 100 characters or less"),Error("Invalid file name length");try{o.oR.info("Preparing to retrieve keys...");let[c]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),m=await e.account.programState.fetch(c);if(!m)throw Error("Program is not initialized");let[u]=t.SX.PublicKey.findProgramAddressSync([i.from("user_key"),a.toBuffer(),i.from(n)],e.programId),[d]=t.SX.PublicKey.findProgramAddressSync([i.from("user_trials"),a.toBuffer()],e.programId);o.oR.info("Requesting wallet approval for retrieving keys...");let f=await e.methods.retrieveKeys(n).accounts({user:a,userKeyPda:u,userTrials:d,programState:c,owner:m.owner,systemProgram:t.SX.SystemProgram.programId}).transaction(),{blockhash:g}=await r.getLatestBlockhash("confirmed");f.recentBlockhash=g,f.feePayer=a,await l(1e3);try{let a=await s(f,r);console.log("[Solana] Retrieve keys transaction signature:",a),await r.confirmTransaction(a,"confirmed");let t=await e.account.userKey.fetch(u);return o.oR.success("Keys retrieved successfully!"),{key1:t.key1,key2:t.key2,signature:a}}catch(e){throw console.error("[Solana] Retrieve keys transaction signing error:",e),Error("Failed to sign and send transaction: ".concat(e.message||"Unexpected wallet error"))}}catch(e){throw console.error("[Solana] Retrieve keys error:",e),o.oR.error("Failed to retrieve keys: ".concat(e.message)),e}}async function f(e,r,a,s,c){let m=0;for(;m<3;)try{if(s<=0||s>1e12)throw Error("Invalid fee amount");o.oR.info("Preparing to update fee...");let[l]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),m=await r.getBalance(a),u=await r.getMinimumBalanceForRentExemption(0);if(m<u)throw Error("Insufficient SOL for transaction fees");let d=new n.Transaction,f=await e.methods.updateFee(new t.BN(s)).accounts({owner:a,programState:l,systemProgram:t.SX.SystemProgram.programId}).instruction();d.add(f);let{blockhash:g,lastValidBlockHeight:y}=await r.getLatestBlockhash("confirmed");d.recentBlockhash=g,d.feePayer=a,o.oR.info("Requesting wallet approval...");let p=await c(d,r);return await r.confirmTransaction({signature:p,blockhash:g,lastValidBlockHeight:y},"confirmed"),o.oR.success("Fee updated successfully!"),p}catch(r){let e=r.message||"Failed to update fee";if(r.message.includes("blockhash")&&++m<3){await l(2e3);continue}throw o.oR.error(e),Error(e)}throw Error("Failed to update fee after ".concat(3," retries"))}async function g(e,r,a,s,c){let m=0;for(;m<3;)try{if(s<=0||s>100)throw Error("Invalid max trials amount");o.oR.info("Preparing to update max trials...");let[l]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),m=await r.getBalance(a),u=await r.getMinimumBalanceForRentExemption(0);if(m<u)throw Error("Insufficient SOL for transaction fees");let d=new n.Transaction,f=await e.methods.setTrialTries(s).accounts({owner:a,programState:l,systemProgram:t.SX.SystemProgram.programId}).instruction();d.add(f);let{blockhash:g,lastValidBlockHeight:y}=await r.getLatestBlockhash("confirmed");d.recentBlockhash=g,d.feePayer=a,o.oR.info("Requesting wallet approval...");let p=await c(d,r);return await r.confirmTransaction({signature:p,blockhash:g,lastValidBlockHeight:y},"confirmed"),o.oR.success("Max trials updated successfully!"),p}catch(r){let e=r.message||"Failed to update max trials";if(r.message.includes("blockhash")&&++m<3){await l(2e3);continue}throw o.oR.error(e),Error(e)}throw Error("Failed to update max trials after ".concat(3," retries"))}async function y(e,r,a,s){let c=0;for(;c<3;)try{o.oR.info("Preparing to close accounts...");let[c]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),l=await r.getBalance(a),m=await r.getMinimumBalanceForRentExemption(0);if(l<m)throw Error("Insufficient SOL for transaction fees");let u=new n.Transaction,d=await e.methods.closeAccounts().accounts({owner:a,programState:c,systemProgram:t.SX.SystemProgram.programId}).instruction();u.add(d);let{blockhash:f,lastValidBlockHeight:g}=await r.getLatestBlockhash("confirmed");u.recentBlockhash=f,u.feePayer=a,o.oR.info("Requesting wallet approval...");let y=await s(u,r);return await r.confirmTransaction({signature:y,blockhash:f,lastValidBlockHeight:g},"confirmed"),o.oR.success("Accounts closed successfully!"),y}catch(r){let e=r.message||"Failed to close accounts";if(r.message.includes("blockhash")&&++c<3){await l(2e3);continue}throw o.oR.error(e),Error(e)}throw Error("Failed to close accounts after ".concat(3," retries"))}async function p(e){try{let[r]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),a=await e.account.programState.fetch(r);return{owner:a.owner,feeAmount:Number(a.feeAmount),maxTrials:a.maxTrials,bump:a.bump}}catch(e){return null}}async function w(e,r){let a;try{[a]=t.SX.PublicKey.findProgramAddressSync([i.from("user_trials"),r.toBuffer()],e.programId),console.log("[Solana] Fetching user trials for PDA:",a.toBase58());let n=new Promise((e,r)=>setTimeout(()=>r(Error("Fetch user trials timed out")),1e4)),o=e.account.userTrials.fetch(a),s=await Promise.race([o,n]);return console.log("[Solana] User trials fetched:",s),{trialCount:s.trialCount,bump:s.bump}}catch(e){return e.message.includes("Account does not exist")||e.message.includes("no data")?console.log("[Solana] No user trials account found for user:",r.toBase58()):console.error("[Solana] getUserTrials error:",{message:e.message}),null}}function h(e,r){try{return e.addEventListener("FeeUpdatedEvent",e=>{r(e.newFee.toNumber(),e.updatedBy)})}catch(e){throw console.error("[Solana] Failed to set up FeeUpdatedEvent listener:",e),o.oR.error("Failed to set up event listener"),e}}function S(e,r){try{return e.addEventListener("MaxTrialsUpdatedEvent",e=>{r(e.newMaxTrials,e.updatedBy)})}catch(e){throw console.error("[Solana] Failed to set up MaxTrialsUpdatedEvent listener:",e),o.oR.error("Failed to set up event listener"),e}}async function P(e){try{let[r]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),a=await e.account.programState.fetch(r);if(!a.owner)throw Error("Owner not found in program state");return a.owner}catch(e){throw console.error("[Solana] Failed to fetch contract owner:",e),o.oR.error("Failed to fetch contract owner"),e}}async function b(e){try{let[r]=t.SX.PublicKey.findProgramAddressSync([i.from("program_state")],e.programId),a=await e.account.programState.fetch(r);return{owner:a.owner,programStatePda:r,feeAmount:Number(a.feeAmount),maxTrials:a.maxTrials,bump:a.bump}}catch(e){return console.error("[Solana] Failed to fetch contract infos:",e),o.oR.error("Failed to fetch contract information"),null}}}}]);